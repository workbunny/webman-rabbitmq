<?php

declare(strict_types=1);
/**
 * @author workbunny/Chaz6chez
 * @email chaz6chez1993@outlook.com
 */

namespace Workbunny\WebmanRabbitMQ\Traits;

use Bunny\ChannelStateEnum;
use Bunny\ClientStateEnum;
use Bunny\Protocol\MethodChannelOpenOkFrame;
use Webman\Context;
use Workbunny\WebmanRabbitMQ\Channels\Channel;
use Workbunny\WebmanRabbitMQ\Exceptions\WebmanRabbitMQChannelException;
use Workerman\Coroutine;
use Workerman\Coroutine\Pool;
use Workerman\Timer;

trait ChannelsMethods
{
    /**
     * @var Pool|null
     */
    protected ?Pool $channelsPool = null;

    /**
     * 获取通道池
     *
     * @return Pool|null
     */
    public function channelsPool(): ?Pool
    {
        if (!$this->channelsPool) {
            $this->channelsPool = new Pool($this->getChannelLimit(), $this->getConfig('channels_pool', []));
            $this->channelsPool->setConnectionCreator(function () {
                $channelId = $this->findChannelId();
                $response = $this->channelOpen($channelId);
                if ($response instanceof MethodChannelOpenOkFrame) {
                    return $this->channels[$channelId] = new Channel($this, $channelId);
                } else {
                    $this->state = ClientStateEnum::ERROR;
                    throw new WebmanRabbitMQChannelException(
                        'channel.open unexpected response of type ' . gettype($response) .
                        (is_object($response) ? '(' . get_class($response) . ')' : '') .
                        '.'
                    );
                }
            });
            $this->channelsPool->setConnectionCloser(function (Channel $channel) {
                try {
                    $channel->close();
                    $this->removeChannel($channel->getChannelId());
                } catch (\Throwable) {
                }
            });
        }
        return $this->channelsPool;
    }

    /**
     * 获取通道
     *
     * @return Channel
     * @throws WebmanRabbitMQChannelException
     */
    public function channel(): Channel
    {

        $channel = Context::get('workbunny.webman-rabbitmq.channel');
        if (!$channel) {
            try {
                /** @var Channel $channel */
                $channel = $this->channelsPool()->get();
            } catch (Coroutine\Exception\PoolException | \Throwable) {
                throw new WebmanRabbitMQChannelException('No available channel.', -999999999);
            }
            Context::set('workbunny.webman-rabbitmq.channel', $channel);
            Coroutine::defer(function () use ($channel) {
                try {
                    // non-ready, close it or put it back
                    if (in_array($channel->getState(), [
                        ChannelStateEnum::ERROR, ChannelStateEnum::CLOSED, ChannelStateEnum::CLOSING,
                    ])) {
                        $this->channelsPool()->closeConnection($channel);
                    } else {
                        $this->channelsPool()->put($channel);
                    }
                } catch (\Throwable) {
                }
            });

            return $channel;
        } else {
            // check current coroutine context.channel state
            if ($channel->getState() === ChannelStateEnum::READY) {
                return $channel;
            }
            // not ready, close it or put it back
            try {
                if (in_array($channel->getState(), [ChannelStateEnum::ERROR, ChannelStateEnum::CLOSED, ChannelStateEnum::CLOSING])) {
                    self::channelsPool()->closeConnection($channel);
                } else {
                    self::channelsPool()->put($channel);
                }
            } catch (\Throwable) {
            }
            // reset context
            Context::set('workbunny.webman-rabbitmq.channel', null);
            // transfer control to other coroutines
            Timer::sleep(0);
            // get new channel
            $channel = $this->channel();
        }

        return $channel;
    }
}
