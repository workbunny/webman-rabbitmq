<?php

declare(strict_types=1);

namespace Workbunny\WebmanRabbitMQ;

use SplFileInfo;
use Workbunny\WebmanRabbitMQ\Builders\AbstractBuilder;
use Workbunny\WebmanRabbitMQ\Connections\ConnectionInterface;
use Workbunny\WebmanRabbitMQ\Exceptions\WebmanRabbitMQPublishException;
use Workerman\Coroutine;
use Workerman\Coroutine\Parallel;

/**
 * 生产
 * @param AbstractBuilder $builder
 * @param string $body
 * @param string|null $routingKey
 * @param array|null $headers
 * @return bool
 */
function publish(AbstractBuilder $builder, string $body, ?string $routingKey = null, ?array $headers = null): bool
{
    $config = new BuilderConfig($builder->getBuilderConfig()());
    if (
        ($config->getExchangeType() !== Constants::DELAYED and $headers['x-delay'] ?? 0) or
        ($config->getExchangeType() === Constants::DELAYED and !($headers['x-delay'] ?? 0))
    ) {
        throw new WebmanRabbitMQPublishException('Invalid publish. ');
    }
    $config->setBody($body);
    $config->setHeaders($headers ?? $config->getHeaders());
    $config->setRoutingKey($routingKey ?? $config->getRoutingKey());

    return $builder->action(function (ConnectionInterface $connection) use ($config) {
        dump($connection, Coroutine::getCurrent()->id());
        return $connection->publish($config);
    });
}

/**
 * 并行生产
 *
 * @param AbstractBuilder $builder
 * @param array<string, string|null, array|null> $multiData
 * @return array<int, array<bool, string|null>> = [
 *   [true, null],
 *   [false, 'Invalid publish. '],
 *   [false, null],
 * ]
 */
function parallel_publish(AbstractBuilder $builder, array $multiData): array
{
    $config = new BuilderConfig($builder->getBuilderConfig()());
    return $builder->action(function (ConnectionInterface $connection) use ($config, $multiData) {
        $p = new Parallel();
        $result = [];
        foreach ($multiData as $key => [$body, $routingKey, $headers]) {
            $p->add(function () use ($connection, $config, $key, $body, $routingKey, $headers, &$result) {
                if (
                    ($config->getExchangeType() !== Constants::DELAYED and $headers['x-delay'] ?? 0) or
                    ($config->getExchangeType() === Constants::DELAYED and !($headers['x-delay'] ?? 0))
                ) {
                    $result[$key] = [false, 'Invalid publish. '];
                    return;
                }
                $config->setBody($body);
                $config->setHeaders($headers ?? $config->getHeaders());
                $config->setRoutingKey($routingKey ?? $config->getRoutingKey());
                $result[$key] = [$connection->publish($config), null];
            });
        }
        $p->wait();
        return $result;
    });
}

/**
 * @param string $path
 * @param bool $remove
 * @return bool
 */
function is_empty_dir(string $path, bool $remove = false): bool
{
    $dirIterator = new \RecursiveDirectoryIterator($path, \FilesystemIterator::FOLLOW_SYMLINKS);
    $iterator = new \RecursiveIteratorIterator($dirIterator);

    /** @var SplFileInfo $file */
    foreach ($iterator as $file) {
        if ($file->getFilename() !== '.' and $file->getFilename() !== '..') {
            if ($file->isDir()) {
                is_empty_dir($file->getPath());
            } else {
                return false;
            }
        }
    }
    if ($remove) {
        rmdir($path);
    }

    return true;
}

/**
 * produce a hex+ASCII dump of a binary string.
 *
 * @param string $binary Binary input string to dump.
 * @param int $bytesPerLine Number of bytes to show per line (default 16).
 * @param bool $showAscii Whether to include the ASCII column (default true).
 * @param bool $uppercase Whether hex letters are uppercase (default true).
 * @return string Formatted multi-line hex dump.
 */
function binary_dump(string $binary, int $bytesPerLine = 16, bool $showAscii = true, bool $uppercase = true): string
{
    $total = strlen($binary);
    $output = '';
    $formatHexByte = $uppercase ? '%02X' : '%02x';
    // ensure a sensible minimum
    if ($bytesPerLine < 1) {
        $bytesPerLine = 16;
    }
    for ($offset = 0; $offset < $total; $offset += $bytesPerLine) {
        // offset column (8 hex digits)
        $line = sprintf('%08X  ', $offset);
        $chunkLen = min($bytesPerLine, $total - $offset);
        $hexPart = '';
        $asciiPart = '';
        for ($i = 0; $i < $chunkLen; $i++) {
            $byte = ord($binary[$offset + $i]);
            // append hex for this byte plus a trailing space
            $hexPart .= sprintf($formatHexByte . ' ', $byte);
            // add an extra space after the 8th byte for readability (if applicable)
            if ($i === 7 && $bytesPerLine > 8) {
                $hexPart .= ' ';
            }
            // build ASCII column: printable ASCII 32..126, otherwise '.'
            if ($showAscii) {
                $asciiPart .= ($byte >= 32 && $byte <= 126) ? chr($byte) : '.';
            }
        }
        // pad hex part so the ASCII column lines up even for short final lines.
        // each byte normally contributes "XX " (3 chars). If bytesPerLine > 8 we added one extra space.
        $expectedHexLen = ($bytesPerLine * 3) + ($bytesPerLine > 8 ? 1 : 0);
        $hexPart = str_pad($hexPart, $expectedHexLen, ' ');
        if ($showAscii) {
            $line .= "$hexPart|$asciiPart|\n";
        } else {
            $line .= rtrim($hexPart) . "\n";
        }
        $output .= $line;
    }

    return $output;
}
